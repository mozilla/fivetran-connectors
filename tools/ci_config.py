import os
import sys
from pathlib import Path

import click
import jinja2
import yaml
from yaml.scanner import ScannerError

ROOT_DIR = (Path(__file__).parent / "..").resolve()
CONNECTOR_DIR = ROOT_DIR / "connectors"
CI_DIR = os.path.join(ROOT_DIR, ".circleci")
CI_CONFIG_TEMPLATE = "config.template.yml"
CI_WORKFLOW_TEMPLATE_NAME = "ci_workflow.yaml"

CI_CONFIG_HEADER = """###
# This config.yml was generated by tools/ci_config.py.
# Changes should be made to templates/config.template.yml and re-generated.
###"""


def validate_yaml(yaml_path: Path) -> bool:
    """Load a yaml file and return the success of the parse."""
    with open(yaml_path) as f:
        try:
            yaml.safe_load(f)
        except ScannerError:
            return False
    return True


def update_config(dry_run: bool = False) -> str:
    """Collect job and workflow configs per job and create new config."""
    template_loader = jinja2.FileSystemLoader(CI_DIR)
    template_env = jinja2.Environment(loader=template_loader)
    config_template = template_env.get_template("config.template.yml")

    workflow_configs = sorted(
        [
            obj
            for obj in CONNECTOR_DIR.glob(f"*/{CI_WORKFLOW_TEMPLATE_NAME}")
            if obj.is_file()
        ]
    )
    connectors = [
        os.path.basename(f.path) for f in os.scandir(CONNECTOR_DIR) if f.is_dir()
    ]

    invalid_configs = [
        str(conf.relative_to(ROOT_DIR))
        for conf in workflow_configs
        if not validate_yaml(conf)
    ]
    if len(invalid_configs) > 0:
        print("Error: Invalid CI configs", file=sys.stderr)
        print("\n".join(invalid_configs), file=sys.stderr)
        sys.exit(1)

    config_text = config_template.render(
        config_header=CI_CONFIG_HEADER,
        workflows="\n\n".join(
            [file_path.read_text() for file_path in workflow_configs]
        ),
        connectors=connectors,
    )

    if dry_run:
        print(config_text)
    else:
        with open(ROOT_DIR / ".circleci" / "config.yml", "w") as f:
            f.write(config_text)

    return config_text


@click.command()
@click.option(
    "--dry-run/--no-dry-run",
    default=False,
    help="Dry run will print to stdout instead of overwriting config.yml",
)
def main(dry_run: bool):
    update_config(dry_run)


if __name__ == "__main__":
    main()
